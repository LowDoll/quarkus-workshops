[[azure-local-running-app]]
= Running the Application Locally

'''

This chapter explores how you can deploy Quarkus applications in containers and Cloud platforms.
There are many different approaches to achieve these deployments.
In this chapter, we are focusing on the creation of containers using Quarkus native executables and the deployment of our system in Kubernetes/OpenShift.

== Building containers

In this section, we are going to package our microservices into containers.
In particular, we are going to produce Linux 64 bits native executables and runs them in a container.
The native compilation uses the OS and architecture of the host system.

And... Linux Containers are ... _Linux_.
So to build a container with a Linux native executable (even if you are on Windows or Mac), Quarkus comes with a trick to produce these executable.
First, Quarkus comes with a set of `Dockerfiles`.
The `Dockerfile.native` file is for running the application in native mode.
It looks like this:

[source,text]
----
FROM registry.access.redhat.com/ubi8/ubi-minimal:8.5
WORKDIR /work/
RUN chown 1001 /work \
    && chmod "g+rwX" /work \
    && chown 1001:root /work
COPY --chown=1001:root target/*-runner /work/application

EXPOSE 8080
USER 1001

CMD ["./application", "-Dquarkus.http.host=0.0.0.0"]
----

It's a pretty straightforward `Dockerfile` taking a minimal base image and copying the generated native executable.
Then, to build the containers with a Linux native executable, Quarkus comes with a set of options:


[source,shell]
----
./mvnw clean package -Pnative -Dquarkus.native.container-build=true -Dquarkus.container-image.build=true -DskipTests
----

The result of this command is a Linux 64 bits executable packaged in a Docker container.
That's because the previous command has different parameters that are worth explaining:

* `-Dquarkus.native.container-build=true` allows running the native compilation inside a container (provided by Quarkus).
* `-Dquarkus.container-image.build=true` creates a Docker image
* `-DskipTests` does not run the tests to save time

[TIP]
====
Building a native executable takes time, CPU, and memory.
It's even more accurate in the container.
So, first, be sure that your container system has enough memory to build the executable.
It requires at least 6Gb of memory, 8Gb is recommended.
====

icon:hand-point-right[role="red", size=2x] [red big]#Call to action#

Execute the above command for all our microservices and the UI.
This will build Docker images out of Linux native executables:

[source,shell]
----
cd rest-hero
./mvnw clean package -Pnative -Dquarkus.native.container-build=true -Dquarkus.container-image.build=true -DskipTests
cd ..

cd rest-villains
./mvnw clean package -Pnative -Dquarkus.native.container-build=true -Dquarkus.container-image.build=true -DskipTests
cd ..

cd rest-fights
./mvnw clean package -Pnative -Dquarkus.native.container-build=true -Dquarkus.container-image.build=true -DskipTests
cd ..

cd event-statistics
./mvnw clean package -Pnative -Dquarkus.native.container-build=true -Dquarkus.container-image.build=true -DskipTests
cd ..

cd ui-super-heroes
./mvnw clean package -Pnative -Dquarkus.native.container-build=true -Dquarkus.container-image.build=true -DskipTests
cd ..
----

Check that you have all the Docker images installed locally:

[source,shell]
----
$ docker image ls | grep ORG
ORG/ui-super-heroes       1.0.0-SNAPSHOT  141MB
ORG/event-statistics      1.0.0-SNAPSHOT  161MB
ORG/rest-fights           1.0.0-SNAPSHOT  187MB
ORG/rest-villains         1.0.0-SNAPSHOT  167MB
ORG/rest-heroes           1.0.0-SNAPSHOT  165MB
----

[NOTE]
====
Replace `ORG` with your DockerHub / Quay.io username.
====

== Running local containers

Now that we have all our Docker containers created, let's execute them all to be sure that everything is working.

icon:hand-point-right[role="red", size=2x] [red big]#Call to action#

Under `super-heroes/infrastructure` you will find the`docker-compose-app.yaml` file.
It declares all the needed infratructure (databases, Kafka) as well as our microservices.
Make sure you edit the file and change the name `ORG` with your own Docker login, and execute it with:

[source,shell]
----
docker compose -f docker-compose-app.yaml up
----

Go to http://localhost:8080.
You should see the user interface and you should be able to fight super heroes against super villains.
Then, make sure you shutdown the entire application with:

[source,shell]
----
docker compose -f docker-compose-app.yaml down
----

== Pushing containers to Azure Container Registry

Now that we have all our Docker containers running locally, let's push them to Azure Container Registry.
https://azure.microsoft.com/services/container-registry[Azure Container Registry] is a private registry for hosting container images.
Using the Azure Container Registry, you can store Docker-formatted images for all types of container deployments.

icon:hand-point-right[role="red", size=2x] [red big]#Call to action#

First, let's created an Azure Container Registry with the following command:

[source,shell]
----
az acr create \
  --resource-group "$RESOURCE_GROUP" \
  --location "$LOCATION" \
  --tags system="$TAG" \
  --name "$REGISTRY" \
  --workspace "$LOG_ANALYTICS_WORKSPACE" \
  --sku Standard \
  --admin-enabled true
----

Get the URL of the Azure Container Registry and set it to the `REGISTRY_URL` variable with the following command:

[source,shell]
----
REGISTRY_URL=$(az acr show \
  --resource-group "$RESOURCE_GROUP" \
  --name "$REGISTRY" \
  --query "loginServer" \
  --output tsv)
----

[NOTE]
====
Make sure you've set all the environment variables defined in the previous chapter and that you've also created the resource group.
====

If you log into the https://portal.azure.com[Azure Portal] you should see the following created resources.

image::azure-portal-2.png[]

icon:hand-point-right[role="red", size=2x] [red big]#Call to action#

Now, let's push these Docker images to Azure Registry.
For that, we first need to log in to the registry:

[source,shell]
----
az acr login \
  --name "$REGISTRY"
----

You should see the prompt _Login Succeeded_.
Before you can push an image to your registry, you must tag it with the fully qualified name of your registry login server (the `REGISTRY` variable).
Tag the image using the `docker tag` commands (replace `ORG` with your Docker id):

[source,shell]
----
docker tag ORG/ui-super-heroes:1.0.0-SNAPSHOT  $HEROES_IMAGE
docker tag ORG/event-statistics:1.0.0-SNAPSHOT  $STATISTICS_IMAGE
docker tag ORG/rest-fights:1.0.0-SNAPSHOT  $FIGHTS_IMAGE
docker tag ORG/rest-villains:1.0.0-SNAPSHOT  $VILLAINS_IMAGE
docker tag ORG/rest-heroes:1.0.0-SNAPSHOT  $HEROES_IMAGE
----

Then, push all the images with the following commands:

[source,shell]
----
docker push $HEROES_IMAGE
docker push $STATISTICS_IMAGE
docker push $FIGHTS_IMAGE
docker push $VILLAINS_IMAGE
docker push $HEROES_IMAGE
----

[source,shell]
----
az acr repository list \
  --name "$REGISTRY" \
  --output table
----

az acr repository list --name <registry-name> --output table

== Running local remote containers

Now that we have all our Docker containers pushed to Azure Container Registry, let's execute them.

icon:hand-point-right[role="red", size=2x] [red big]#Call to action#

Let's go back to the `docker-compose-app.yaml` file under `super-heroes/infrastructure`.
Edit the file and change the name `ORG` with the value of the `$REGISTRY` variable, and then execute it with:

[source,shell]
----
docker compose -f docker-compose-app.yaml up
----

Go to http://localhost:8080.
You should see the user interface and everything should work.
Remember to shutdown the entire application with:

[source,shell]
----
docker compose -f docker-compose-app.yaml down
----

Ok, enough running these containers locally, let's push them to Azure Container Apps!
