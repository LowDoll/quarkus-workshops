[[azure-local-running-app]]
= Running the Application Locally

'''

This chapter explores how you can deploy Quarkus applications in containers and Cloud platforms.
There are many different approaches to achieve these deployments.
In this chapter, we are focusing on the creation of containers using Quarkus native executables and the deployment of our system in Kubernetes/OpenShift.

== Building containers

In this section, we are going to package our microservices into containers.
In particular, we are going to produce Linux 64 bits native executables and runs them in a container.
The native compilation uses the OS and architecture of the host system.

And... Linux Containers are ... _Linux_.
So to build a container with a Linux native executable (even if you are on Windows or Mac), Quarkus comes with a trick to produce these executable.
First, Quarkus comes with a set of `Dockerfiles`.
The `Dockerfile.native` file is for running the application in native mode.
It looks like this:

[source,text]
----
FROM registry.access.redhat.com/ubi8/ubi-minimal:8.5
WORKDIR /work/
RUN chown 1001 /work \
    && chmod "g+rwX" /work \
    && chown 1001:root /work
COPY --chown=1001:root target/*-runner /work/application

EXPOSE 8080
USER 1001

CMD ["./application", "-Dquarkus.http.host=0.0.0.0"]
----

It's a pretty straightforward `Dockerfile` taking a minimal base image and copying the generated native executable.
Then, to build the containers with a Linux native executable, Quarkus comes with a set of options:


[source,shell]
----
./mvnw clean package -Pnative -Dquarkus.native.container-build=true -Dquarkus.container-image.build=true -DskipTests
----

The result of this command is a Linux 64 bits executable packaged in a Docker container.
That's because the previous command has different parameters that are worth explaining:

* `-Dquarkus.native.container-build=true` allows running the native compilation inside a container (provided by Quarkus).
* `-Dquarkus.container-image.build=true` creates a Docker image
* `-DskipTests` does not run the tests to save time

[TIP]
====
Building a native executable takes time, CPU, and memory.
It's even more accurate in the container.
So, first, be sure that your container system has enough memory to build the executable.
It requires at least 6Gb of memory, 8Gb is recommended.
====

icon:hand-point-right[role="red", size=2x] [red big]#Call to action#

Execute the above command for all our microservices and the UI.
This will build Docker images out of Linux native executables:

[source,shell]
----
cd rest-hero
./mvnw clean package -Pnative -Dquarkus.native.container-build=true -Dquarkus.container-image.build=true -DskipTests
cd ..

cd rest-villains
./mvnw clean package -Pnative -Dquarkus.native.container-build=true -Dquarkus.container-image.build=true -DskipTests
cd ..

cd rest-fights
./mvnw clean package -Pnative -Dquarkus.native.container-build=true -Dquarkus.container-image.build=true -DskipTests
cd ..

cd event-statistics
./mvnw clean package -Pnative -Dquarkus.native.container-build=true -Dquarkus.container-image.build=true -DskipTests
cd ..

cd ui-super-heroes
./mvnw clean package -Pnative -Dquarkus.native.container-build=true -Dquarkus.container-image.build=true -DskipTests
cd ..
----

Check that you have all the Docker images installed locally:

[source,shell]
----
$ docker image ls | grep ORG
ORG/ui-super-heroes       1.0.0-SNAPSHOT  141MB
ORG/event-statistics      1.0.0-SNAPSHOT  161MB
ORG/rest-fights           1.0.0-SNAPSHOT  187MB
ORG/rest-villains         1.0.0-SNAPSHOT  167MB
ORG/rest-heroes           1.0.0-SNAPSHOT  165MB
----

[NOTE]
====
Replace `ORG` with your DockerHub / Quay.io username.
====

== Pushing containers to Azure Container Registry

https://azure.microsoft.com/services/container-registry[Azure Container Registry] is a private registry for hosting container images.
Using the Azure Container Registry, you can store Docker-formatted images for all types of container deployments.

icon:hand-point-right[role="red", size=2x] [red big]#Call to action#

[source,shell]
----
az acr create \
  --resource-group "$RESOURCE_GROUP" \
  --location "$LOCATION" \
  --tags system="$TAG" \
  --name "$REGISTRY" \
  --workspace "$LOG_ANALYTICS_WORKSPACE" \
  --sku Standard
----

If you log into the https://portal.azure.com[Azure Portal] you should see the following created resources.

image::azure-portal-2.png[]


icon:hand-point-right[role="red", size=2x] [red big]#Call to action#

Now, let's push these Docker images to Azure Registry.


[NOTE]
====
Make sure you've set all the environment variables defined in the previous chapter and that you've also created the resource group.
====

== Executing the containers Locally
