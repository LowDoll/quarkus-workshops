[[cloud]]
= Containers & Cloud (optional)

:icons: font

'''

This chapter explores how you can deploy Quarkus applications in containers and Cloud platforms.
There are many different approaches to achieve these deployments.
In this chapter, we are focusing on the creation of containers using Quarkus java executables and the deployment of our system in OpenShift.

== From bare metal to containers

In this section, we are going to package our microservices into containers.
In particular, we are going to produce java executables and runs them in a container.

icon:hand-o-right[role="red", size=2x] [red big]#Call to action#

Execute the above command for all our microservices.
We also copy the UI into the fight service, to simplify the process:

[source, shell]
----
cd rest-hero
mvn clean package -DskipTests
cd ..
cd rest-villain
mvn clean package -DskipTests
cd ..
cd rest-fight
cp -R ../ui-super-heroes/dist/* src/main/resources/META-INF/resources
mvn clean package -DskipTests
cd ..
----

== Building containers

Now that we have the executables, we can build containers.
When you create projects, Quarkus generates two `Dockerfiles`:

1. `Dockerfile.jvm` - A `Dockerfile` for running the application in JVM mode
2. `Dockerfile.native` - A `Dockerfile` for running the application in native mode

We are interested in the first file.
Open one of these `Dockerfile.jvm` files:

[source, text]
----
FROM fabric8/java-alpine-openjdk8-jre
ENV JAVA_OPTIONS="-Dquarkus.http.host=0.0.0.0 -Djava.util.logging.manager=org.jboss.logmanager.LogManager"
ENV AB_ENABLED=jmx_exporter
COPY target/lib/* /deployments/lib/
COPY target/*-runner.jar /deployments/app.jar
ENTRYPOINT [ "/deployments/run-java.sh" ]
----

It's a pretty straightforward `Dockerfile` taking a minimal base image and copying the generated java executable.
It also exposes the port 8080.
Wait, our microservices are not configured to run on the port 8080.
We need to override this property as well as a few other such as the HTTP client endpoints, and database locations.

To build the containers, use the following scripts:

[source, shell]
----
export ORG=xxxx
cd rest-hero
docker build -f src/main/docker/Dockerfile.native -t $ORG/quarkus-workshop-hero .
cd ..
cd rest-villain
docker build -f src/main/docker/Dockerfile.native -t $ORG/quarkus-workshop-villain .
cd ..
cd rest-fight
docker build -f src/main/docker/Dockerfile.native -t $ORG/quarkus-workshop-fight .
cd ..
cd event-statistics
docker build -f src/main/docker/Dockerfile.native -t $ORG/quarkus-workshop-stats .
cd ..
----

[NOTE]
====
Replace `ORG` with your DockerHub / Quay.io username.
====

== Deploying on Kubernetes

This section is going to deploy our microservices on Kubernetes.
It is required to have access to a OpenShift cluster.

[IMPORTANT]
====
To deploy your microservices, push the built container images to an image registry accessible by your cluster, such as Quay.io or DockerHub.
====

We recommend using a specific namespace to deploy your system.
In the following sections, we use the `quarkus-workshop` namespace.

=== Deploying the infrastructure

The infrastructure has been deployed at the beginning of the workshop.

You should have the following resources:

[source,shell]
----
$ oc get database
NAME                AGE
fights-database     16h
heroes-database     16h
villains-database   16h
----

=== Deploying the Hero & Villain microservices

Now we can deploy our microservices.
Let's start with the hero and villain microservices.

For each, we need to override the port and data source URL.

icon:hand-o-right[role="red", size=2x] [red big]#Call to action#

Create a config map with the following content:

[source,yaml]
.config-hero.yaml
----
apiVersion: v1
data:
    port: "8083"
    database: "jdbc:postgresql://heroes-database.USERNAME-heroes:5432/heroes_database"
kind: ConfigMap
metadata:
    name: hero-config
----

[NOTE]
--
Make sure you replace the `USERNAME` with your own
--

icon:hand-o-right[role="red", size=2x] [red big]#Call to action#

Do the same for the villain and the fight microservices.

[source,yaml]
.config-villain.yaml
----
apiVersion: v1
data:
    port: "8084"
    database: "jdbc:postgresql://villains-database.USERNAME-heroes:5432/villains_database"
kind: ConfigMap
metadata:
    name: hero-config
----

[source,yaml]
.config-fight.yaml
----
apiVersion: v1
data:
    port: "8082"
    database: "jdbc:postgresql://fights-database.USERNAME-heroes:5432/fights_database"
kind: ConfigMap
metadata:
    name: hero-config
----

Then, apply these resources:

[source,shell]
----
$ oc apply -f config-hero.yaml
$ oc apply -f config-villain.yaml
$ oc apply -f config-fight.yaml
----

Once the config maps are created, we can deploy the microservices.

icon:hand-o-right[role="red", size=2x] [red big]#Call to action#

Create a `deployment-hero.yaml` file with the following content:

[source,yaml]
----
---
apiVersion: "v1"
kind: "List"
items:
    - apiVersion: "v1"
      kind: "Service"
      metadata:
          labels:
              app: "quarkus-workshop-hero"
              version: "01"
              group: "$ORG"
          name: "quarkus-workshop-hero"
      spec:
          ports:
              - name: "http"
                port: 8080
                targetPort: 8080
          selector:
              app: "quarkus-workshop-hero"
              version: "01"
              group: "$ORG"
          type: "ClusterIP"
    - apiVersion: "apps/v1"
      kind: "Deployment"
      metadata:
          labels:
              app: "quarkus-workshop-hero"
              version: "01"
              group: "$ORG"
          name: "quarkus-workshop-hero"
      spec:
          replicas: 1
          selector:
              matchLabels:
                  app: "quarkus-workshop-hero"
                  version: "01"
                  group: "$ORG"
          template:
              metadata:
                  labels:
                      app: "quarkus-workshop-hero"
                      version: "01"
                      group: "$ORG"
              spec:
                  containers:
                      - image: "$ORG/quarkus-workshop-hero:latest"
                        imagePullPolicy: "IfNotPresent"
                        name: "quarkus-workshop-hero"
                        ports:
                            - containerPort: 8080
                              name: "http"
                              protocol: "TCP"
                        env:
                            - name: "KUBERNETES_NAMESPACE"
                              valueFrom:
                                  fieldRef:
                                      fieldPath: "metadata.namespace"

                            - name: QUARKUS_DATASOURCE_URL
                              valueFrom:
                                  configMapKeyRef:
                                      name: hero-config
                                      key: database

                            - name: QUARKUS_HTTP_PORT
                              valueFrom:
                                  configMapKeyRef:
                                      name: hero-config
                                      key: port


----

This descriptor declares:

1. A service to expose the HTTP endpoint
2. A deployment that instantiates the application

The deployment declares one container using the container image we built earlier.
It also overrides the configuration for the HTTP port and database URL.

icon:hand-o-right[role="red", size=2x] [red big]#Call to action#

Don't forget to create the equivalent files for the villain microservice.

Then, deploy the microservice with:

[source,shell]
----
$ oc apply -f deployment-hero.yaml
$ oc apply -f deployment-villain.yaml
----

=== Deploying the Fight microservice

Follow the same approach for the fight microservice.
Note that there are more properties to configure from the config map:

*  the location of the hero and villain microservice
*  the location of the Kafka broker.

Once everything is configured and deployed, your system is now running on OpenShift.
